{{define "content"}}
{{/* Per AI.md PART 32: Tor is ONLY for hidden service, NOT for outbound proxy */}}
<div class="card">
    <h2>Hidden Service Status</h2>
    <table class="info-table">
        <tr><td>Tor Binary</td><td>{{if .TorInstalled}}<span class="badge badge-success">Installed</span>{{else}}<span class="badge badge-warning">Not Installed</span>{{end}}</td></tr>
        <tr><td>Service Status</td><td>{{if .TorRunning}}<span class="badge badge-success">Running</span>{{else}}<span class="badge badge-warning">Stopped</span>{{end}}</td></tr>
        {{if .TorRunning}}
        <tr><td>.onion Address</td><td>{{if .OnionAddress}}<code>{{.OnionAddress}}</code>{{else}}<span class="text-muted">Not configured</span>{{end}}</td></tr>
        {{end}}
    </table>
    <p class="help-text mt-md">Hidden service auto-starts when Tor binary is installed. No configuration required.</p>
</div>

{{if .TorInstalled}}
<div class="card">
    <h2>Onion Service</h2>
    <table class="info-table">
        <tr><td>Status</td><td>{{if .OnionEnabled}}<span class="badge badge-success">Active</span>{{else}}<span class="badge badge-warning">Disabled</span>{{end}}</td></tr>
        {{if .OnionEnabled}}
        <tr><td>Address</td><td><code>{{.OnionAddress}}</code></td></tr>
        {{end}}
    </table>
    <form id="onion-form" onsubmit="saveOnionSettings(event)">
        <div class="form-group">
            <label class="toggle-label">
                <input type="checkbox" id="onion-enabled"{{if .OnionEnabled}} checked{{end}}>
                <span>Enable Onion Service</span>
            </label>
        </div>
        <div class="button-group">
            <button type="submit" class="btn btn-primary">Save Changes</button>
            {{if .OnionEnabled}}
            <button type="button" onclick="regenerateOnion()" class="btn btn-warning">Regenerate Address</button>
            {{end}}
        </div>
    </form>
</div>

<div class="card">
    <h2>Vanity Address Generator</h2>
    <p class="text-muted">Generate a custom .onion address with a specific prefix. Runs in background.</p>

    <div id="vanity-status" class="d-none mb-md">
        <div class="alert alert-info">
            <strong>Generation in progress:</strong>
            <span id="vanity-prefix-display"></span>
            <br>
            <span id="vanity-attempts"></span> attempts |
            <span id="vanity-elapsed"></span> elapsed
            <div class="mt-sm">
                <button onclick="cancelVanity()" class="btn btn-sm btn-warning">Cancel</button>
            </div>
        </div>
    </div>

    <div id="vanity-ready" class="d-none mb-md">
        <div class="alert alert-success">
            <strong>Vanity address ready!</strong>
            Prefix: <code id="vanity-ready-prefix"></code>
            <br>
            <span id="vanity-ready-attempts"></span> attempts |
            <span id="vanity-ready-elapsed"></span>
            <div class="mt-sm">
                <button onclick="applyVanity()" class="btn btn-sm btn-primary">Apply Address</button>
                <button onclick="cancelVanity()" class="btn btn-sm btn-warning">Discard</button>
            </div>
        </div>
    </div>

    <form id="vanity-form" onsubmit="generateVanity(event)">
        <div class="form-group">
            <label for="vanity-prefix">Desired Prefix</label>
            <input type="text" id="vanity-prefix" placeholder="vidv" maxlength="6" pattern="[a-z2-7]+">
            <p class="help-text">Use only lowercase a-z and digits 2-7 (max 6 chars). Longer = slower.</p>
        </div>
        <table class="info-table my-md">
            <tr><td>1-2 chars</td><td>Instant - few seconds</td></tr>
            <tr><td>3 chars</td><td>Minutes</td></tr>
            <tr><td>4 chars</td><td>~1 hour</td></tr>
            <tr><td>5 chars</td><td>~1 day</td></tr>
            <tr><td>6 chars</td><td>~1 month</td></tr>
        </table>
        <div class="button-group">
            <button type="submit" class="btn btn-primary" id="vanity-start-btn">Start Generation</button>
        </div>
    </form>
</div>

<div class="card">
    <h2>Import Existing Key</h2>
    <p class="text-muted">Import an existing onion service private key.</p>
    <form id="import-form" onsubmit="importOnionKey(event)">
        <div class="form-group">
            <label for="onion-key">Private Key (base64)</label>
            <textarea id="onion-key" rows="3" placeholder="ED25519-V3 private key in base64 format"></textarea>
        </div>
        <div class="button-group">
            <button type="submit" class="btn btn-secondary">Import Key</button>
        </div>
    </form>
</div>
{{else}}
<div class="card">
    <div class="alert alert-info">
        <strong>Tor not installed</strong>
        <p>Install Tor to enable hidden service functionality.</p>
        <code>apt install tor</code> or <code>apk add tor</code>
    </div>
</div>
{{end}}
{{end}}

{{define "scripts"}}
<script>
async function saveOnionSettings(e) {
    e.preventDefault();
    try {
        const resp = await fetch(window.API_BASE + '/server/tor', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                enabled: document.getElementById('onion-enabled').checked
            })
        });
        const data = await resp.json();
        if (data.success) { showSuccess('Hidden service settings saved!'); }
        else { showError('Error: ' + data.error); }
    } catch (e) { showError('Error: ' + e.message); }
}

function regenerateOnion() {
    showConfirm('Are you sure? This will generate a new .onion address and invalidate the current one.', async function() {
        try {
            const resp = await fetch(window.API_BASE + '/server/tor/regenerate', { method: 'POST' });
            const data = await resp.json();
            if (data.success) { showSuccess('New onion address generated!'); location.reload(); }
            else { showError('Error: ' + data.error); }
        } catch (e) { showError('Error: ' + e.message); }
    });
}

// Vanity generation status polling
let vanityPollInterval = null;

document.addEventListener('DOMContentLoaded', function() {
    checkVanityStatus();
    vanityPollInterval = setInterval(checkVanityStatus, 3000);
});

async function checkVanityStatus() {
    try {
        const resp = await fetch(window.API_BASE + '/server/tor/vanity');
        const data = await resp.json();
        if (!data.success) return;

        const statusDiv = document.getElementById('vanity-status');
        const readyDiv = document.getElementById('vanity-ready');
        const startBtn = document.getElementById('vanity-start-btn');

        if (data.data.active) {
            // Generation in progress
            statusDiv.classList.remove('d-none');
            readyDiv.classList.add('d-none');
            startBtn.disabled = true;
            startBtn.textContent = 'Generation in progress...';

            document.getElementById('vanity-prefix-display').textContent = data.data.prefix;
            document.getElementById('vanity-attempts').textContent = data.data.attempts.toLocaleString();
            document.getElementById('vanity-elapsed').textContent = data.data.elapsed_time || '0s';
        } else if (data.data.pending_ready) {
            // Generation complete, ready to apply
            statusDiv.classList.add('d-none');
            readyDiv.classList.remove('d-none');
            startBtn.disabled = true;
            startBtn.textContent = 'Address ready - apply or discard first';

            document.getElementById('vanity-ready-prefix').textContent = data.data.prefix;
            document.getElementById('vanity-ready-attempts').textContent = data.data.attempts.toLocaleString();
            document.getElementById('vanity-ready-elapsed').textContent = data.data.elapsed_time || '';

            // Show notification
            if (Notification && Notification.permission === 'granted') {
                new Notification('Vanity Address Ready!', {
                    body: 'Your vanity .onion address with prefix "' + data.data.prefix + '" is ready.'
                });
            }
        } else {
            // No generation
            statusDiv.classList.add('d-none');
            readyDiv.classList.add('d-none');
            startBtn.disabled = false;
            startBtn.textContent = 'Start Generation';
        }
    } catch (e) {
        console.error('Failed to check vanity status:', e);
    }
}

async function generateVanity(e) {
    e.preventDefault();
    const prefix = document.getElementById('vanity-prefix').value.toLowerCase();
    if (!prefix) { showError('Please enter a prefix'); return; }
    if (prefix.length > 6) { showError('Prefix must be 6 characters or less'); return; }
    if (!/^[a-z2-7]+$/.test(prefix)) { showError('Prefix must only contain a-z and 2-7'); return; }

    try {
        const resp = await fetch(window.API_BASE + '/server/tor/vanity', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prefix: prefix })
        });
        const data = await resp.json();
        if (data.success) {
            showSuccess('Vanity generation started for "' + prefix + '"!');
            // Request notification permission
            if (Notification && Notification.permission === 'default') {
                Notification.requestPermission();
            }
            checkVanityStatus();
        } else {
            showError('Error: ' + data.error);
        }
    } catch (e) { showError('Error: ' + e.message); }
}

function applyVanity() {
    showConfirm('Apply this vanity address? This will replace your current .onion address.', async function() {
        try {
            const resp = await fetch(window.API_BASE + '/server/tor/vanity/apply', { method: 'POST' });
            const data = await resp.json();
            if (data.success) {
                showSuccess('Vanity address applied! Restart Tor service to use new address.');
                checkVanityStatus();
            } else {
                showError('Error: ' + data.error);
            }
        } catch (e) { showError('Error: ' + e.message); }
    });
}

async function cancelVanity() {
    try {
        const resp = await fetch(window.API_BASE + '/server/tor/vanity', { method: 'DELETE' });
        const data = await resp.json();
        if (data.success) {
            showSuccess('Vanity generation cancelled');
            checkVanityStatus();
        } else {
            showError('Error: ' + data.error);
        }
    } catch (e) { showError('Error: ' + e.message); }
}

async function importOnionKey(e) {
    e.preventDefault();
    const key = document.getElementById('onion-key').value;
    if (!key) { showError('Please enter a private key'); return; }
    try {
        const resp = await fetch(window.API_BASE + '/server/tor/import', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ private_key: key })
        });
        const data = await resp.json();
        if (data.success) { showSuccess('Key imported successfully!'); location.reload(); }
        else { showError('Error: ' + data.error); }
    } catch (e) { showError('Error: ' + e.message); }
}
</script>
{{end}}
